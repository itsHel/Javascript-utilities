#php
	echo substr($string, 0, -3);
	
	<?php header("HTTP/1.0 418 I'm A Teapot"); die;?>			// custom http response

	I found that $_POST and $_GET don't work well with Fetch API. You have to use php://input to get all the data sent to the server.
	file_get_contents('php://input')

	$start = microtime(true); 
	$end = (microtime(true) - $start);
	echo "elapsed time: ".number_format($end, 15)." s";
	
	If you must store your configuration files in the document root, name the files with a .php extension
		
	create pepper in file for full security ?
	
	register_shutdown_function(function($delPath){ unlink($delPath); exit(); }, dirname(__FILE__)."/".$zipPath);
	
	$file = fopen("error_log_new.txt", "a+");
    fwrite($file, "[".date('Y-m-d H:i:s')."]\n"."EXIT"."\n\n");
	
	while($fileExists = file_exists($path)){
         $filename = "_".$filename;
         $path = dirname(__FILE__)."/../pdf/".$filename;
    }
	
	#streaming headers
		header("Cache-Control: no-cache, must-revalidate");
		header('X-Accel-Buffering: no');
		header('X-Accel-Charset: no');
		header('Content-type: text/event-stream');
		header("Content-Encoding: identity");
		header('Surrogate-Control: BigPipe/1.0');
		
	- email buttons - https://buttons.cm/
	
#mail
	<!--[if mso]>
		<p>Something for Outlook only</p>
	<![endif]-->
	
	<!--[if !mso]><!-->
		<p>Something for everything but Outlook</p>                
	<!--<![endif]-->
	
#html
	<input id="" type="datetime-local" style="color:rgba(0,0,0,0.4);" autocomplete="off" onfocus="this.style.color='#212529'" onblur="if(this.value!=='') this.style.color='#212529'; else this.style.color='rgba(0,0,0,0.4)'">
	<input id="" placeholder="Expiration" type="search" autocomplete="off">
	
	<span class="material-icons-outlined">cruelty_free</span>
	
ðŸ˜ŽðŸ˜¥
#debug
	$0 - $4
	debug(), dir(), monitor, getEventListeners
	function trace - console.log((new Error()).stack);
	

create an alternate (alias) email address to use for account. Example: "example@gmail.com", "example+tag@gmail.com"
	
let type = m.match(/\b(first|second)\b/);
	
$(window).on("click", "#myelement", function(){
    // Will work on dynamically added elements!
});

"keypress"	- not registering esc, enter, etc

// data to formData 
function buildFormData(formData, data, parentKey) {
  if (data && typeof data === 'object' && !(data instanceof Date) && !(data instanceof File)) {
    Object.keys(data).forEach(key => {
      buildFormData(formData, data[key], parentKey ? `${parentKey}[${key}]` : key);
    });
  } else {
    const value = data == null ? '' : data;

    formData.append(parentKey, value);
  }
}

#cors servers
	- https://thingproxy.freeboard.io/fetch/https://
	
#date
	new Date().getTime()										! 1620732518800
	new Date().toLocaleString("sv")								! "2021-05-26 15:46:09"
	
for(const property in object)
	
#JSON.parse(window.localStorage["buttons"] || "[]");

specifiedElement.contains(event.target);

this.style.setProperty( 'border', 'none', 'important' );

$(".modal.js-product-images-modal").on('transitionend webkitTransitionEnd oTransitionEnd', function(){});

window.navigator.userAgent.match(/MSIE|Trident/)

document.activeElement

$0.scrollHeight			// Real height pri max-height:0; nebo height:0; returns 0 for display:none

pageDiv.insertAdjacentHTML('beforeend', myCanvas);

$(content).hide().appendTo("body").css({});

document.designMode = "on";

#animate after display:block
	$("#reg-content").css({display: "none"});
	$("#login-content").css({display: "block"});
	$("#login-content")[0].clientWidth;
	$("#login-content").addClass("content-show").siblings().removeClass("content-show");
	
	
element.addEventListener( action, function name () {
    element.removeEventListener( action, name, capture );
}, capture );

document.styleSheets[1].cssRules[0].style.getPropertyValue('--modal-warn-color');

font-display: fallback;
 
window.getComputedStyle( document.body).getPropertyValue('background-color');  

element.style.left = left; // triggers reflow
element.style.top = top; // triggers reflow
element.style.cssText += "left: " + left + "px; top: " + top + "px;"; // triggers reflow once

for loops that force layout & change the DOM are the worst, avoid them.

// Better performance when hidden outside of For
search.addEventListener('keyup', function() {
    const nodesToHide = [];
    const nodesToShow = [];
    for (const node of nodes)
        if (node.innerText.toLowerCase().includes(this.value.toLowerCase()))
            nodesToShow.push(node);
        else
            nodesToHide.push(node);

    nodesToHide.forEach(node => node.classList.add('hidden'));
    nodesToShow.forEach(node => node.classList.remove('hidden'));
});

let t0 = performance.now();
let t1 = performance.now();
console.log("Call to do Something took " + (t1 - t0) + " milliseconds.");

https://www.computerhope.com/htmcolor.htm

const $ = document.querySelectorAll.bind(document);

window.getSelection().selectAllChildren(footer);

const blob = await new Promise(resolve => el.toBlob(resolve));

[1, 2, 3].map(x => x <= 2);

document.designMode = "on"

function createFormData(formData, key = "", data) {
    if (data === Object(data) || Array.isArray(data)) {
        for (var i in data) {
            createFormData(formData, key + '[' + i + ']', data[i]);
        }
    } else {
        formData.append(key, data);
    }
}

let formData = new FormData();
page.forEach((el) => {
	formData.append("canvasEdits[" + i + "][page]", page.dataset.pageNumber);     
	formData.append("canvasEdits[" + i + "][content]", page.dataset.content);
	i++;
});

#return promise
function promiseForTransaction(tx) {
  return new Promise((resolve, reject) => {
    tx.oncomplete = e => resolve();
    tx.onabort = e => reject(tx.error);
  });
}
await promiseForTransaction(r.tx);

Usage example:
	var data = {a: '1', b: 2, c: {d: '3'}};
	var formData = new FormData();
	createFormData(formData, 'data', data);
	
https://ritwickdey.github.io/

https://gist.github.com/niksumeiko/360164708c3b326bd1c8		disable autofill/autocomplete

#async callback
	foo(function(result) {
		// Code that depends on 'result'
	});
	Here we defined the function "inline" but you can pass any function reference:

	function myCallback(result) {
		// Code that depends on 'result'
	}

	foo(myCallback);
	foo itself is defined as follows:

	function foo(callback) {
		$.ajax({
			// ...
			success: callback
		});
	}



// #Hold scroll and then release calculated move
scrollControl: function(){
	const deltaMultiple = 1;

	const container = $("#viewerContainer")[0];
	container.addEventListener("scroll", detectScroll, {passive: true, once: true});

	const delay = 2222;
	const triggerMove = container.offsetHeight / 2;

	let oldPos = container.scrollTop, newPos;
	let triggered = false;
	let oldTime = 0;
	let delta = 0;
	let Timeout;
	let holdX = 0, holdY = 0;
	let highestDiff = 0;
	let scrollDirection = "";

	function detectScroll(){
		newPos = container.scrollTop;
		let now = Date.now();

		if(!triggered){
			// On scroll start
			triggered = true;
			oldTime = now;
			oldPos = newPos;
			container.addEventListener("scroll", detectScroll, {passive: true, once: true});

			clearTimeout(Timeout);
			Timeout = setTimeout(detectScroll, delay + 50);
			return;
		}

		if(oldTime > now - delay){
			// Keep counting
			let newDiff = newPos - oldPos;
			
			let newScrollDirection = (newDiff > 0) ? "bot" : "top";
			if(newDiff == 0){
				newScrollDirection = scrollDirection;
			}

			if(newScrollDirection != scrollDirection){
				finishScroll();
				scrollDirection = newScrollDirection;
				return;
			}
			scrollDirection = newScrollDirection;

			// var RenderingStates = { INITIAL: 0, RUNNING: 1, PAUSED: 2, FINISHED: 3 };
			if(newScrollDirection == "bot"){
				// Scrolling bottom
				var lastPagesRendering = (
					PDFViewerApplication.pdfViewer._pages[PDFViewerApplication.pdfViewer._currentPageNumber - 1].renderingState != 3
					&& (PDFViewerApplication.pdfViewer._pages[PDFViewerApplication.pdfViewer._currentPageNumber - 2]?.renderingState != 3)
					&& (PDFViewerApplication.pdfViewer._pages[PDFViewerApplication.pdfViewer._currentPageNumber]?.renderingState != 3)
				);
			} else {
				// Scrolling top
				var lastPagesRendering = (
					PDFViewerApplication.pdfViewer._pages[PDFViewerApplication.pdfViewer._currentPageNumber - 1].renderingState != 3
					&& PDFViewerApplication.pdfViewer._pages[PDFViewerApplication.pdfViewer._currentPageNumber]?.renderingState != 3
					&& PDFViewerApplication.pdfViewer._pages[PDFViewerApplication.pdfViewer._currentPageNumber - 2]?.renderingState != 3
				);
			}
			
			console.log("lastPagesRendering: " + lastPagesRendering);

			if(lastPagesRendering){
				
				if(Math.abs(highestDiff) > Math.abs(newDiff)){
					delta += highestDiff;
				}

				oldTime = now;
				
				highestDiff = newDiff;
				// console.log("scrolldelta: " + delta);
				if(Math.abs(delta) > triggerMove){
					// Surpress scroll
					if(holdX || holdY){
						console.log("DELATA:   " + delta);
						container.scrollTo(holdX, holdY);
					} else {
						holdX = container.scrollLeft;
						holdY = container.scrollTop;
						console.log("stay at: " + holdY);
					}
				}
			} else {
				// If lastPagesRendering went from true to false
				if(holdX || holdY){
					holdX = 0;
					holdY = 0;
				}
			}

			container.addEventListener("scroll", detectScroll, {passive: true, once: true});

			clearTimeout(Timeout);
			Timeout = setTimeout(detectScroll, delay + 50);
		} else {
			console.log("second reset");
			finishScroll(true);
			return;
		}

		if(!(Math.abs(delta) > triggerMove))
			oldPos = newPos;
		else
			oldPos = holdY;
	}

	function finishScroll(move = false){
		clearTimeout(Timeout);
		
		if(move && (holdX || holdY)){
			 container.removeEventListener("scroll", detectScroll);
			 container.scrollTo(holdX, holdY + (delta * deltaMultiple));
		}
		
		holdX = 0;
		holdY = 0;
		oldTime = 0;
		highestDiff = 0;
		oldPos = holdY;
		triggered = false;
		
		container.addEventListener("scroll", detectScroll, {passive: true, once: true});   
	}
},
